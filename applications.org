#-*- mode: org -*-
#+startup: showall
#+title: A NOTE ABOUT APPLICATIONS TO INSTALL BY HAND
#+author: ELISE N
#+date: 2021-10-04 Mon
#+seq_todo: TODO() | IN-PROGRESS() | WAINTING(w) | CANCELLED(c) | DONE(d)
#+options: toc:t

* "Tenir un fichier texte dans le quel tu listes toutes les commandes d'installation utilisé:

#+begin_src
- 06/10/2020 sudo snap install gitkraken --classic
  + link:
    + [[https://support.gitkraken.com/how-to-install/]]
    + [[https://snapcraft.io/gitkraken]]
  + data location:
    + GitKraken data is stored in
      #+begin_src
      /home/{user}/.gitkraken == ~/.gitkraken
      #+end_src
  + run =gitkraken=
-

#+end_src



| Date/Month/Year | How to install | Type |
|-----------------+----------------+------|
|E.g : 01/02/2020 apt install eclipse     |
|E.g : 04/08/2020 snap install nesus      |

"La façon de faire de Linux ne pousse pas à installer n'impoter quoi."

"Sinon tes un peu niqué le jour ou tu veux faire le ménage."

* Lists 
Course/dotfiles-from-start-to-finish-ish

~/.dotfiles/Brewfile

- [X] tap "homebrew/bundle"
- [X] tap "homebrew/cask"
- [X] brew "bat"
- [X] brew "exa"
- [X] brew "git"
- [X] brew "httpie"
- [ ] cask "alfred"
- [ ] cask "dropbox"
- [ ] cask "gitkraken"
- [ ] cask "google-chrome"
- [ ] cask "visual-studio-code"
- [ ]

* TODO Manually
- [ ] alfred
- [ ] dropbox
- [ ] gitkraken
      + [[https://support.gitkraken.com/how-to-install/]]
- [ ] google-chrome
      + [[https://doc.ubuntu-fr.org/google_chrome]]
      + "Google Chrome est le navigateur internet propriétaire développé par Google sur la base du navigateur libre Chromium.
      Il n'est pas recommandé de l'utiliser, étant donné que des /problèmes de confidentialité sont très présents/.
      Si vous utilisez Google Chrome sur Windows ou macOS,
      utilisez plutôt Chromium, qui récolte moins de données personnelles que Chrome,
      ou encore Firefox, qui ne récolte rien du tout, et qui est le navigateur par défaut d'Ubuntu." 
- [ ]

* Ubuntu Software

Synaptic 0.90.2 (package management software using apt):
- Origin
- All
- Package
- Home Page
  + [[http://www.nongnu.org/synaptic/]]

Other Software: 

Software 3.38.1 (A nice way to manage the software on your system):
Installed:
- [X] visual-studio-code
      + package: code
      + synaptic (package management software using apt)
        + Local/main (packages.microsoft.com)
      + http://packages.microsoft.com/repos/code stable main
- [X] Regolith-desktop environtment
      + synaptic (package management software using apt)
        + LP-PPA-regolith-linux-release/hirsute
        + LP-PPA-regolith-linux-release/now
      + http://ppa.launchpad.net/regolith-linux/release/ubuntu/hirsute main
      + [[https://regolith-linux.org/docs/getting-started/install/#ppa-sources]][Install Regolith]
      + install the standard variant of Regolith Desktop from the release PPA:
        #+begin_src
        $ sudo add-apt-repository ppa:regolith-linux/release
        $ sudo apt install regolith-desktop-standard
        #+end_src
- [X] Chromium Web Browser
      + -via-> snap
      + package: chromium-browser
      + synaptic (package management software using apt)
        + Local/universe (archive.ubuntu.com)
        + visite homepage
          + [[https://chromium.googlesource.com/chromium/src/]]
      + [[https://doc.ubuntu-fr.org/google_chrome]]
- [X] firefox
      + package: firefox
      + synaptic (package management software using apt)
        + Local/main (archive.ubuntu.com)
- [X] brave-browser
      + package: brave-browser-beta
      + synaptic (package management software using apt)
        + Local/main (brave-browser-apt-beta.s3.brave.com)
        + stable/main (brave-browser-apt-beta.s3.brave.com)
- [X] intellij-idea-community
      + -via-> snap
      + package:
      + synaptic (package management software using apt)
        + ?/universe
        + visite homepage
          + [[https://github.com/JetBrains/intellij-community]]
- [X] atom
      + package:atom
      + synaptic (package management software using apt)
        + Local/main (packagecloud.io)
- [ ] conda
      + [[https://docs.conda.io/en/latest/]]
- [ ] anaconda
      + [[https://docs.anaconda.com/anaconda/install/index.html]]
- [X] vim
      + package: vim
      + synaptic (package management software using apt)
        + Local/main (archive.ubuntu.com)
        + [[https://www.vim.org/]]
- [X] emacs
      + package: emacs
      + synaptic (package management software using apt)
        + Local/universe (archive.ubuntu.com)
- [X] tmux
      + synaptic (package management software using apt)
        + Local/main (archive.ubuntu.com)
- [X] LaTex: pdfTeX
      + [[https://en.wikipedia.org/wiki/PdfTeX]]
      + [[https://www.latex-project.org/get/]]
      + TeX Distributions: Linux
        + texlive-full
          + [[https://www.tug.org/texlive/]]
- [X] TeXstudio
      + [[https://www.texstudio.org/]]
      + TeXstudio is an integrated writing environment for
        creating LaTeX documents.
- [X] virtualbox 
     + package: vitualbox, virtualbox-dkms, virtuablox-qt
     + synaptic (package management software using apt)
       + Local/multiverse(archive.ubuntu.com)
       + visite homepage
         + [[https://www.virtualbox.org/]]
- [X] anki
      + package: anki
      + synaptic (package management software using apt)
        + Local/universe(archive.ubuntu.com)
        + visite homepage
          + [[https://apps.ankiweb.net/]]
- [X] audacity
      + package: audacity
      + synaptic (package management software using apt)
        + Local/universe(archive.ubuntu.com)
        + visite homepage
          + [[https://www.audacityteam.org/]]
- []
- []

** How to get a list of all repositories and PPAs?
[[https://askubuntu.com/questions/148932/how-can-i-get-a-list-of-all-repositories-and-ppas-from-the-command-line-into-an]]

[[https://askubuntu.com/questions/17823/how-to-list-all-installed-packages]]

- RTFM: =man apt-add-repository=
- RTFM: =man apt=
- SEE ALSO
      + apt-get(8), apt-cache(8), sources.list(5), apt.conf(5), apt-config(8),
      + The APT User's guide in /usr/share/doc/apt-doc/, apt_preferences(5),
      + the APT Howto.
- look into:
  + =/etc/apt/sources.list=
  + =/etc/apt/sources.list.d/=
  + =/etc/apt/preferences.d/=
- =ls -lAFh /usr/local/share=
- =ls -lAFh /etc/apt=

** How to listppa Script to get all the PPA installed on a system ready to share for reininstall?
#+begin_src
# Create shell script fonctions "list-apt-repositories":
# - lists all repisitories in "/ect/sources.list"
# - and "/etc/sources.list.d/*.list"
# - to show only the PPAs: can add =--ppa-only=
# - PPAs are automatically transformed to =ppa:USER/REPO= format

# 1. list_sources
# 2. list_ppa
   
# Make an install script, pipe into another script "make-apt-repository-install-script":
# - generated script supports the =-y/yes= argument for non-interactive use (see =add-apt-repository=(1))
# - xargs -d'\n' printf "add-apt-repository \$y '%s'\n"
#+end_src
** =apt-mark showmanual= will print a list of manually installed packages
[[https://askubuntu.com/questions/17823/how-to-list-all-installed-packages]]

RTFM: =man apt-mark=

To output the result into a text file:

#+begin_src
pwd
cd ~/Desktop
mkdir packages

apt-mark showmanual > ~/Desktop/packages/list-manually-installed.txt
#+end_src

** Apt-Get List Installed Packages - List All Installed Packages with *apt* on Ubuntu

[[https://www.rosehosting.com/blog/list-all-installed-packages-with-apt-on-ubuntu/]]

RTFM: =man apt=

To output the result into a text file:

#+begin_src
pwd
cd ~/Desktop
mkdir packages

sudo apt list --installed > ~/Desktop/packages/list_installed_software_packages_on_ubuntu.txt
#+end_src

1. List the installed software packages on Ubuntu:
   - =sudo apt list --installed=
2. Use the LESS program: to read the entire output
   - =sudo apt list --installed | less=
3. Use the GREP command: list all packages that include Apache
   - =sudo apt list --installed | grep -i apache=
4. Use the DPKG program: another alternative that list the installed software packages
   on your *Ubuntu VPS* in the *dpkg* command 
   - =sudo dpkg -l=
5. The output of the command *dpkg* will provide information:
   - name of the package
   - version
   - architecture
   - a short description of the package
   - Use the *grep* program to search for a specific package:
     + =sudo dpkg -l | grep -i apache= 


* Repositories and package management
[[https://itsfoss.com/ppa-guide/]][PPA GUIDE]

What is a repository?
A repository is a collection of files that has information about various software:
- their versions and some other details like the checksum.

Each Ubuntu version has its own official set of four repositories:
1. *Main* - Canonical-supported free and open-source software.
2. *Universe* - Community-maintained free and open-source software.
3. *Restricted* - Proprietary drivers for devices.
4. *Multiverse* - Software restrited by copyright or legal issues.

** Linux Package Managers
[[https://www.tecmint.com/linux-package-managers/]][linux-package-managers]

DPKG (Debian Package Management System):
- Dpkg is a base package management system for the Debian Linux family.
- it is used to install, remove, store and provide information about =.deb packages=.
- a low-level tool and there are front-end tools that help users to obtain packages from
  remote repositories and/or handle complex package relations and these include:
  + APT (Advanced Package Tool):
    + useful command line package management system that is a front end for dpkg package management system.
    + Users of Debian or its derivatives such as Ubuntu and Linux Mint should be familiar with this package management tool.
  + Aptitude Package Manager:
    + command line front-end package management tool for Debian Linux family, it works similar to APT 
    + It was initially built for Debian and its derivatives but now its functionality stretches to RHEL family as well.
  + Synaptic Package Manager:
    Synaptic is a GUI package management tool for APT based on GTK+ and
    it works fine for users who may not want to get their hands dirty on a command line.
    It implements the same features as apt-get command line tool.


** =sudo apt= vs =sudo apt-get=
[[https://askubuntu.com/questions/445384/what-is-the-difference-between-apt-and-apt-get]]

[[https://debian-handbook.info/browse/stable/sect.apt-get.html]][aptitude, apt-get, and apt Commands]

[[https://itsfoss.com/apt-vs-apt-get-difference/]]

RTFM: "man apt", "man apt-get", "man apt-cache", "man snap", "man df", "man dpkg"

What is apt?
- APT mostly obtains packages from a distribution's official repositories.
- apt is a second command-line based front end provided by APT which overcomes some design mistakes of apt-get.
- with apt, you get all the necessary tools in one place. "pleasant for end users".
- apt == most command used commanand options from apt-get and apt-cache.
- apt is a subset of apt-get and apt-cache commands
- apt-get won't be deprecated, as a regular user, you should start using apt more ofter.

| new apt command | function of the command                                  |
|-----------------+----------------------------------------------------------|
| apt list        | Lists packages with criteria (installed, upgradable etc) |
| apt edit-source | Edits sources list                                       |


| apt command     | the command it replaces | function of the command  |
|-----------------+----------------------------------------------------|
| apt search      | apt-cache search        | Searches for the program |
| apt show        | apt-cache show          | Show package details     |

** External sources, PPAs or packages downloaded from websites

Hybrid system that mixes and matches snaps and traditional DEB-based installations?

[[https://ubuntu.com/core]][What is Ubuntu Core 20?]

Get third-party software to Ubuntu users:
1. Ubuntu Advanced Package Tool (Apt)
2. Ubuntu Snap
3. “Personal Package Archives” (PPAs) with =apt install=
4. homebrew
5. Flatpak
6. git clone
7. ISO
8. install from source
   - =./configure=
   - =make=
   - =make install=
   - =dpkg -i pkg.deb=
   - =rpm -Uvh pkg.rpm=

[[https://openclassrooms.com/forum/sujet/snap-ou-apt]][snap ou apt (openclassrooms)]

[[https://help.ubuntu.com/stable/ubuntu-help/addremove-ppa.html.en]][Add a Personal Package Archive (PPA)]

[[https://itsfoss.com/ppa-guide/]][Using PPA in Ubuntu Linux]

[[https://snapcraft.io/about]][snapcrat]

[[https://www.howtogeek.com/670084/what-you-need-to-know-about-snaps-on-ubuntu-20.04/]]

[[https://fr.wikipedia.org/wiki/Snap_(gestionnaire_de_paquet)]]

Apps, apps, everywhere:
- "The Linux desktop has seen great advances in *desktop app containerization* and
  *process-isolating sandbox-technologies*. Keeping programs from getting hold of 
  each other’s environments and files can greatly /improve security/
  if something where to go wrong with a program.
  /Flatpak and Snap are the two leading implementations on the desktop/."

What is Snap, snaps, snapd?
- “Snap” refers to both the snap command and a snap installation file.
  A snap bundles an application and all its dependents into one compressed file.
  The dependents might be library files, web or database servers,
  or anything else an application must have to launch and run.
- Snap is developed by *Canonical* for *operating systems* that use
  the *Linux* kernel. The packages, called /snaps/.
- Snap is *a software package and deployment system* that uses
  *self-contained packages* called snaps to deliver software to users.
- Snap enables developpers to deliver their apps directly to users via Snap Store.
- avoid *Dependency hell*.

- Snaps are packages:
  + using a snap allows me to /avoid cluttering *apt with PPA*/ that I can avoid using.  
  + the installation files are bigger than the traditional *Debian package manager (DEB) files*.
  + use more hard drive real estate.
  + during the installation. The snaps took a lot longer to download.
  + Launching applications is slower.
  + updated automatically.
  + not always "official". They're ofter built by well-intentioned voluteers.

- Is the Snap Store open source?
  + [[https://merlijn.sebrechts.be/blog/2020-08-02-why-done-snap-store/]]
  + part of the Snap store is still closed source.
  + Snap itself is completely open source and many parts of the Snap store are open source
  + The back-end hosting the snaps, however, is still proprietary.

What is PPA?
- Personal Package Archives (PPAs) are software repositories designed for
  Ubuntu users and are easier to install than other third-party repositories.
  PPAs are often used to distribute pre-release software so that it can be tested. 
- The PPA allows application developers and Linux users to create their own repositories to distribute software.
  With PPA, you can easily get newer software version or software that are not available
  via the official Ubuntu repositories.
- it brought in newer libraries as dependencies that
  your native programs were unable to use or overwrote your installed libraries with
  older ones that were too outdated to be used by your native Ubuntu.

What is Flatpak?

[[https://merlijn.sebrechts.be/blog/2020-07-03-snap-vs-flatpak/]]

[[https://www.ctrl.blog/entry/firefox-linux-flatpak-snap.html]]

[[https://www.techrepublic.com/article/why-snap-and-flatpak-are-so-important-to-linux/]]

[[https://askubuntu.com/questions/1179175/are-snap-and-flatpak-apps-safe-to-install-are-they-official-approved-or-test]][are snap and flatpak apps safe to install]

Are Snap and Flatpak apps safe to install?
  - both snaps and Flatpaks is that they will bring in any libraries they need to run inside their own folders.
    Snaps and Flatpaks are *self-contained* and will not touch any of your system files or libraries.
  - The disadvantage to this is that the programs might be bigger than
    a non snap or Flatpak version but the trade off is that you don't have to
    worry about it affecting anything else, not even other snaps or Flatpak.
    If the app is broken because it brought in bad libraries or
    for any other reason you just uninstall it and it is completely gone.  
 - Official repos for such:
   + Snaps have the https://snapcraft.io/ repo.
     This is run by Canonical, the same people that build Ubuntu.
   + Flatpaks have an official repo at https://flathub.org/ . 
     Flatpaks were developed by Redhat but I don't know if they manage the flathub repo or not.
- Stability, maintained by ?
- run: slow || faster
- Update, upgrade?
- garbage, outdated or insecure apps?
- Location? Where applications are stored by them?
  + system-wide (global) installs:
  + on the local side:
 
What is homebrew, brew bundle, brew file, brew tap, homebrew-cask, homebrew?
[[https://github.com/Homebrew/homebrew-bundle]]
- Brew Bundle : A Homebrew subcommand to run your Brewfile.
- Brew file : A file where you define softwares and applications you want to install.
- Brew tap : A Homebrew subcommand to add additional repositories which are not in the official formulae.
  + Taps (Repositories)
- Homebrew-cask : A tool which helps you to install Mac applications by using Homebrew.
  + Casks (Applications) # Error: Installing casks is supported only on macOS
- Homebrew : A package manager which helps you to install software. 
  + Brews (Packages) (Formulae)

Summary: Before install app:
  - [[https://merlijn.sebrechts.be/blog/2020-08-17-verify-snap/]][How to verify the source of a Snap package]
  - Learn to *decrypt* the *source code*.
  - check author, current version/last update for *snap version*
  - and same things for *mainstream version*,
  - permissions (it may be "Classic" app with all dangerous permissions).
  - Same things for *PPA*, they are not any trusted quality control.
  - etc

* Via Ubuntu Package manager
GNU/Linux Debian and Ubuntu based distributions

** How to install
#+begin_src
sudo updatedb
sudo apt-get update
apt search <package name>
apt show <package name>
apt list

sudo apt-get install <package name>
# or
sudo apt install <package name>
#+end_src

* Via Snap
[[https://snapcraft.io/code]]

[[https://www.linuxtricks.fr/wiki/ubuntu-supprimer-et-bloquer-les-snaps]]

E.g: Visual Studio Code is officially distributed as a Snap package in the Snap Store:

- RTFM:
- =man snap=
- =snap --version=
- =snap list=
- =snap info=
- "snap install [install-OPTIONS]"

** How to install
#+begin_src
sudo snap install --classic code # or code-insiders

#+end_src

* Via PPA
Installing Visual Studio Code with =apt=

Download and install the =.deb package (64-bit)= from official software website:

** How to install
[[https://code.visualstudio.com/docs/setup/linux]][Visual Studio Code on Linux]

[[https://doc.ubuntu-fr.org/visual_studio_code]][Wiki ubuntu-fr | Installation | Visual Studio Code]

E.g: The easiest way to install Visual Studio Code for Debian/Ubuntu based distributions is to
download and install the =.deb package (64-bit)=, either through the graphical software center
if it's available,or through the command line with:

Installing the .deb package will automatically install the apt repository and
signing key to enable auto-updating using the system's package manager.
Alternatively, the repository and key can also be installed manually with the following script:

#+begin_src
pwd
# =~= : Home folder, current users home directory.
cd ~    # or =cd=
# Create a =src/= directory to store applications to install/uninstall/remove manually
mkdir ~/src/
cd ~/src/
#+end_src

#+begin_src
sudo apt install ./<file>.deb

# If you're on an older Linux distribution, you will need to run this instead:
# sudo dpkg -i <file>.deb
# sudo apt-get install -f # Install dependencies
#+end_src

* Via ISO installs

* Via =git clone= source code

* Welcome to Org mode
[[Quickstart ]][https://orgmode.org/quickstart.html]

* Quickstart
** Preamble
At the start of a file (before the first heading), it is common to set the title,
author and other export options.
#+BEGIN_SRC
#+title: The glories of Org
#+author: A. Org Writer
#+END_SRC
** Heading
#+BEGIN_SRC
* Welcome to Org-mode
** Sub-heading
Each extra ~*~ increases the depth by one level.
#+END_SRC

#+BEGIN_SRC
* TODO Promulgate Org to the world
** TODO Create a quickstart guide
#+END_SRC
** Markup
- *Bold*
- /italic/
- _underline_
- +strikethrough+
- can _/*combine*/_ the basic markup in any order,
- however, ~code~ and =verbatim= need to be the *_~inner-most~_* markers
  if they are present since their contents are interpreted =_literally_=.

#+begin_src
- *Bold*
- /italic/
- _underline_
- +strikethrough+
- can _/*combine*/_ the basic markup in any order,
- however, ~code~ and =verbatim= need to be the *_~inner-most~_* markers
  if they are present since their contents are interpreted =_literally_=.
#+end_src
** Lists
Ordered and unordered bullets can be nested in any order:
- Unordered lists start with =+=, =-=, or =*=[^1].
- Ordered lists start with =1.=, =1)=, =A.=, or =A)=.

Lists can contain checkboxes [ ], [-], [X].
#+begin_src
- [ ] not started
- [-] in progress
- [X] complete
#+end_src

Lists can contains tags (and checkboxes at the same time).
#+begin_src
- [ ] fruits :: get apples
- [ ] veggies :: get carrots
#+end_src
** Links
#+begin_src
[[https://orgmode.org][a nice website]]
[[file:~/Pictures/dank-meme.png]]
[[earlier heading][an earlier heading in the document]]
#+end_src
** Images
#+begin_src
[[https://upload.wikimedia.org/wikipedia/commons/5/5d/Konigsberg_bridges.png]]
#+end_src
** Blocks
Org mode uses #+BEGIN … #+END blocks for many purposes. Some of the basic blocks types quote, example, and src.

If you all you need is monospace text, you can use an example block.

#+BEGIN_SRC
\#+begin_example
monospace
\#+end_example
#+END_SRC

However, example blocks do not give you the power of Org babel.
For that you need a source block. Source blocks provide
syntax highlighting, code execution, literate programming, and more.

#+BEGIN_SRC
\#+begin_src emacs-lisp
(message "Hello world")
\#+end_src
#+END_SRC
** Tables
| Tool         | Literate programming? | Reproducible Research? | Languages |
|--------------+-----------------------+------------------------+-----------|
| Javadoc      | partial               | no                     | Java      |
| Haskell .lhs | partial               | no                     | Haskell   |
| noweb        | yes                   | no                     | any       |
| Sweave       | partial               | yes                    | R         |
| Org-mode     | yes                   | yes                    | any       |

#+begin_src
| Tool         | Literate programming? | Reproducible Research? | Languages |
|--------------+-----------------------+------------------------+-----------|
| Javadoc      | partial               | no                     | Java      |
| Haskell .lhs | partial               | no                     | Haskell   |
| noweb        | yes                   | no                     | any       |
| Sweave       | partial               | yes                    | R         |
| Org-mode     | yes                   | yes                    | any       |

#+end_src
** Comments
# comments invisible
#+begin_src
# comments invisible
#+end_src

Org mode has a variety of ways to add comments.

- Line comments start with #.
- Inline comments wrap @@comment:like so@@.
- Block comments are wrapped with #+BEGIN_COMMENT and #+END_COMMENT.
- Section comments can be created by adding the COMMENT keyword to a heading * COMMENT like so[^2].

#+BEGIN_SRC
# A line comment

Example of an @@comment:inline@@ comment.

Inline comments are used for end of line comments. @@comment:~#~ won't
work@@ Since # only only works if preceeded by a newline follow by
whitespace.

#+begin_comment
This is a block comment.
It can span multiple line.
As well as other markup.
#+begin_src emacs-lisp
(+ 1 2)
#+end_src
#+end_comment

\* A top level heading
\** COMMENT This section and subsections are commented out
\*** This heading inherits the =COMMENT= keyword
This text is commented out
\** This heading is not commented
This text will be exported and code blocks will run.
#+END_SRC
** Macros
#+BEGIN_SRC
#+macro: attn _*/$1/*_
{{{attn(Attention! This text gets all the markup!)}}}

#+html_head: <style>.red{color:red;}</style>
#+latex_header: \usepackage{xcolor}
#+macro: red @@html:<span class="red">$1</span>@@@@latex:\textcolor{red}{$1}@@
Regular text. {{{red(This text will be red.)}}} More regular text.
#+END_SRC

* Hello Worg, the Org-Mode Community!
[[https://orgmode.org/worg/]][worg]

=org4beginner.org=

#+BEGIN_SRC
#+TITLE: Org mode beginning at the basics
#+AUTHOR: Alexander Poslavsky
#+EMAIL: alexander.poslavsky AT gmail DOT com
#+LANGUAGE:  en
#+OPTIONS:    H:2 num:nil toc:t \n:nil ::t |:t ^:nil -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+HTML_LINK_UP:    index.html
#+HTML_LINK_HOME:  https://orgmode.org/worg/

# This file is released by its authors and contributors under the GNU
# Free Documentation license v1.3 or later, code examples are released
# under the GNU General Public License v3 or later.

Org mode, as it says on the [[https://orgmode.org/ ][official web page]] is for keeping notes,
maintaining TODO lists, doing project planning, and authoring with a
fast and effective plain-text system. Beginning with Emacs 22.2 and
XEmacs 22.1 it has been part of Emacs. The following is a simple
tutorial to help you get started using Emacs and Org mode.

* The absolute minimum you need to know about Emacs

The absolute minimum you need to know about Emacs, to be able to do
/anything/, is more then you need to know about many other
applications. But, you might compare it to a regular toy and
lego. Lego is harder to begin with (you start with a box with little
plastic pieces), but in the long run, you can do more with it.

Emacs is heavy on shortcuts. starting out, that is rather annoying,
but in time you'll notice you start to use the mouse less and less,
and you actually start to work quicker.

All the basic things can be done, with the mouse, from the menu, open
file, save file , etc. You will notice, however, that in time it is
faster to use shortcuts, and leave your hands on the keyboard.

Emacs uses a lot of double shortcuts, so instead of Alt-F and Alt-S,
like most applications, it uses *Control-X Control-F* and *Control-X
Control-S*, this seems rather counter-productive in the beginning, but
you'll get used to it.

*Note:* Key abbreviations:

- *M* -- Alt (used to be called Meta on ancient keyboards, that's why)
- *C* -- Control
- *S* -- Shift
- *C-x f* -- means holding both Control /and/ x, release both, and press f

**  What version of Emacs should you choose?

If it is all the same to you, then choose Emacs over XEmacs (if you
disagree then you know already enough to skip this paragraph). Here
are some links to help:

- [[http://aquamacs.org/][Aquamacs: Emacs for Mac OS X]] (my favourite)
- [[http://homepage.mac.com/zenitani/emacs-e.html][Carbon Emacs for OSX]]
- [[http://emacsformacosx.com/][Regular Emacs for OS X]]
- [[http://ftp.gnu.org/gnu/emacs/windows/][Emacs for MS Windows]]

On GNU/Linux, just use your package manager to install Emacs.

On Debian:

#+BEGIN_SRC sh
sudo apt-get install emacs
#+END_SRC

** Configuration

The biggest pain, when you just begin with Emacs, is the
configuration. There is not really a menu for it (you might later hear
there is, but they are lying, that menu is really there to trap
innocent people), you need to edit a text-file. The location of that
config-file (and even the name) is different on different OSes, but
the text in it is mostly the same, across platforms. Many people
actually use the same config-file on different OSes and even over many
years, so in the long run, it is for the best!

Location of the configuration file:

- Aquamacs: =~/Library/Preferences/Aquamacs Emacs/Preferences.el=
- Regular emacs on Linux or OS X: =~/.emacs=
- On Windows: =c:\emacs\.emacs.d\init.txt= ([[http://www.claremontmckenna.edu/math/alee/emacs/emacs.html][according to this example installation]])

* Starting Org mode

New shortcuts in this chapter:

- *C-x C-s* -- save document
- *C-x C-f* -- open document
  
** Our first Org document

By now, we know enough to start our first Org document. Start up
Emacs. If you have a completely new Emacs install, then you should see
the Emacs splash-screen. It has a couple of shortcuts, to the Emacs
tutorial and some other documents, but for now, we don't need those.

To start a new document, use the following short-cut: *C-x C-f*, which
will offer you to open a document (or buffer as it is called in
Emacs), call it *1.org*. This will give you a brand-new, empty document.

To save the document, either press the save icon, or press *C-x C-s*,
call it 1.org.

Emacs does not actually understand you are editing an Org document,
yet. To enable Org mode on your current document, type =M-x org-mode=
which will enable the Org mode on the current document.

To make Emacs understand that this is an Org document, add the
following to the *top* of your document:

#+BEGIN_SRC org
MY PROJECT -*- mode: org -*-
#+END_SRC

Those are minuses, /not/ underscores. MY PROJECT is the title of the
document, this can be anything.

This will enable Org mode for this document, no matter what the
file-ending is.

To enable Org mode to always work on all your Org files, you have to
edit your Emacs configuration, we do that in the following paragraph.
   
** Our first edit to our Emacs configuration

Open your Emacs configuration file (see [[Configuration]]), to open it in
Emacs, use *C-x C-f* (open file), and put the following in it:

#+begin_src emacs-lisp
;; -*- mode: elisp -*-

;; Disable the splash screen (to enable it agin, replace the t with 0)
(setq inhibit-splash-screen t)

;; Enable transient mark mode
(transient-mark-mode 1)

;;;;Org mode configuration
;; Enable Org mode
(require 'org)
;; Make Org mode work with files ending in .org
;; (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
;; The above is the default in recent emacsen
#+end_src

Restart Emacs.

*Note:* The mode-line, mentioned in the previous paragraph is only
needed if you (1) have files with a different file-ending then
configured in your Emacs config (for example myfile.txt).  (2) Don't
have the auto-mode-alist line in your configuration.

* Keep track of lists and notes

New shortcuts in this chapter:

- *TAB* / *S-TAB* -- (un)fold
- *M-up/down* -- move a headline up or down
- *M-left/right* -- promote or demote a headline
- *M-RET* -- insert a new headline
- *C-x C-s* -- save file
- *C-h t* -- Emacs tutorial

Now that we have configured Emacs to work with Org document, we can
actually start using it. Let's begin with an outline that will help us
get to know Org mode. Start a new document (*C-x b*), call it 2.org, and
copy and paste the following in it:

#+BEGIN_SRC org
 #-*- mode: org -*-
 #+STARTUP: showall

 * Welcome to Org mode

   Welcome, and thanks for trying out Org mode. Making outlines in
   Org is very simple. It is just text! Just start typing.
 * This is a headline, it starts with one or more stars
   A heading has one star, a sub-heading two, etc.
 * Working with lists
 ** Moving around in our outline
 ** Moving around headlines
#+END_SRC

Save the file (*C-x C-s*) as 2.org, and you will notice that the colors
change, syntax highlighting is turned on, and Emacs understands you
are working in Org mode.

Now we are ready to really start working with Org mode!

** Working with lists

List are great for brainstorming and to keep track of things. Also it
helps keeping the big picture in mind when taking notes.

The first thing we will do is folding. Especially when you have a long
document, this is very useful. In our example document, go to the
first headline (just use the arrow keys), *Welcome to Org mode*, end
press *TAB*, and now press *S-TAB*. *Tab* will fold and unfold parts or,
using shift and tab, the whole document.

The basic idea of brainstorming is to write a list of items. Then,
later, you might want to change the order of your items, for example
in order of importance. To move a headline up or down, use *M-up/down*,
try it on any of the headlines. Notice that your list folds in,
showing only headings, to give a general overview of the document, and
you don't get lost in the details.

Next we will promote and demote headings. For example you might make
*This is a headline, it starts with one or more stars*, a sub-heading of
*Working with lists*, moving it down, and then using *M-right* to demote
it.

Finally, to add a new headline, press *M-RET*.

Besides headlines there are still other kind of lists, ordered and
unordered lists. They look like this:

#+BEGIN_SRC org
,** Lord of the Rings
   My favorite scenes are (in this order)
   1. The attack of the Rohirrim
   2. Eowyn's fight with the witch king
      + this was already my favorite scene in the book
      + I really like Miranda Otto.
   3. Peter Jackson being shot by Legolas
       - on DVD only
      He makes a really funny face when it happens.
   But in the end, no individual scenes matter but the film as a whole.
   Important actors in this film are:
   - Elijah Wood :: He plays Frodo
   - Sean Austin :: He plays Sam, Frodo's friend.  I still remember
     him very well from his role as Mikey Walsh in The Goonies.
#+END_SRC

Unordered lists start with -,+,or \*. Ordered lists start with a
number and a dot. Descriptions use ::.

Further information: a short [[http://bzg.fr/org-playing-with-lists-screencast.html][screencast]] presenting a few features of
plain lists, also look at the [[https://orgmode.org/manual/Plain-lists.html#Plain-lists][manual]].

** Working with notes

To keep notes, there is some markup to make things stand out a bit
more. You can use the following markup:

: You can make words *bold*, /italic/, _underlined_, =code= and ~verbatim~, and, if you must, +strike-through+.

It will look like this:

You can make words *bold*, /italic/, _underlined_, =code= and
~verbatim~, and, if you must, +strike-through+.

If you like what you see so far, the it might be a good idea to do the
Emacs tutorial, that comes with Emacs itself (*C-h t*). The tutorial
will teach you some more Emacs shortcuts, used to move around in your
documents.

* Working with TODO items

New shortcuts in this chapter:

- *S-left/right* -- cycle workflow
- *C-c / t* -- show TODOs in current document

** Basic TODO functionality

The biggest use-case of Org mode is using it to keep track of
TODOs. To start working with TODOs you don't have to do anything,
just add the TODO keyword in a headline:

#+BEGIN_SRC org
,** TODO buy airplane
#+END_SRC

To speed up working with TODO-list there is the following shortcut
=S-left/right= which will cycle through: *TODO* - *DONE* and empty.

Imagine that you have a large document, with scattered all over the
document TODO entries, *C-c C-v* will show only your current TODOs, and
folding the rest away.

** Configuring TODOs

*** In the file itself
Org mode files can be configured by adding workflow states to the
beginning of the file, like so:

#+BEGIN_SRC org
,#+TODO: TODO IN-PROGRESS WAITING DONE
#+END_SRC

The line shoud be at the top of file, there should /not/ be any empty
lines between the top and the #+TODO line.

To activate the new workflow, either reopen the file, or go to the top
of the file (any line starting with #) and press *C-c C-c*.

Try copying the workflow to your test-file 1.org, seeing it helps
understanding what you can do with it.

*** In the Emacs-config file

Adding the workflow states to every org-file you create gets boring
soon, so it also possible to do this in your config file. Add the
following /after/ the (require 'org) line:

#+BEGIN_SRC lisp
(setq org-todo-keywords
  '((sequence "TODO" "IN-PROGRESS" "WAITING" "DONE")))
#+END_SRC

To activate the workflow states, restart Emacs.

* Agendas

New shortcuts in this chapter:

- *C-c a* -- agenda
- *C-c [* -- add document to the list of agenda files
- *C-c ]* -- remove document from the list of agenda files
- *C-c .* -- add date
- *C-u C-c .* -- add time and date
- *C-g* -- stop doing what you are trying to do, escape

The basic meaning of the word agenda is /things to be done/, coming from
the latin /agendum/. Org mode is very good in making different kind of
agendas, or task-lists, collecting all the tasks from one or more
org-documents.

** Creating lists of all active TODOs

We will start with using 1.org as our basic agenda-file, later we will
see how this works in the Emacs-config file.

So, again, visit =1.org=. Next press *C-c a*, which calls the
agenda. It looks like this:

#+BEGIN_EXAMPLE
Press key for an agenda command
-------------------------------
a Agenda for the current week or day
t List of all TODO entries
#+END_EXAMPLE

and then some more.

Unfortunately, both will show just empty lists (you can try if you
want). So just press *C-g* (the Emacs version of escape). Next we will
add 1.org as agenda file, using *C-c [*. Now if you go to the agenda
menu (*C-c a*), and press *t* you get a list off all your TODO items.

You will also notice that, if you have added a more comprehensive
workflow, as explained in [[Working with TODO items]], all items are
listed, except DONE.

This can be repeated for as many documents as you want, and agenda
will give you a complete list of TODOs. If you want to remove a
documents from the list of agenda files, press *C-c ]*.

** Appointments and deadlines

When a task is time related, then we usually put it in our
calendar. This can also be done in Org mode. And agenda can then show
us a time-based list of all our TODOs. This is done in the following
way.

In =1.org=, add a new (sub-)heading called: /Call fred/ (*M-RET* Call fred),
but at the end press *C-c .*. This will give you, at the bottom of the
screen, the date chooser. You can either type something by hand, or
use *S-left/right* to change the date. If you want to add a time as
well, use *C-u C-c .* instead of *C-c .*.

Now, if you go to the agenda (*C-c a*) and press *a*, you get an agenda
entry!

Further reading:

- [[http://doc.norang.ca/org-mode.html#Clocking][Bernt Hansens extensive description Time Clocking: Usage, Customization,
 Workflow description]]
- [[http://sachachua.com/blog/2007/12/clocking-time-with-emacs-org/][Clocking time with Emacs Org]]
- And of course [[https://orgmode.org/manual/#toc-Dates-and-times-1][the manual]]

** Configuring the agenda in the Emacs configuration file

If you open up your emacs configuration file, after you have used
*C-c [*, you will see the following:

#+BEGIN_SRC emacs-lisp -n -r
(custom-set-variables
  ;; custom-set-variables was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(org-agenda-files (quote ("~/Documents/Projects/org4beginners/2.org"
 "~/Documents/Projects/org4beginners/1.org"))))
(custom-set-faces
  ;; custom-set-faces was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 )
#+END_SRC

Welcome to the world of Emacs lisp. This is what it looks like if
Emacs changes your config file. (*Note:* on Aquamacs, this is in a
separate file called customizations.el)

For us, the important part is in the middle (lines 5 and 6), the line
with /org-agenda-files/. There we see the list of files agenda uses to
create its lists. For now we can just leave it there, but at least you
know what it is, when you later look at your config-file.
   
Further reading: [[https://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html][Custom agenda commands]]

* GTD

New shortcuts in this chapter:

- *C-c C-c* -- add tag

/Getting things done/, is one of the most popular ways to organize
oneself, with 4.3 miljon hits on Google. It is quite possible to use
the same kind of setup in org mode, using tags.

Tags are used to organize different kind of TODO-entries, for
example all tasks on the phone, reading, shopping, etc.

To add tags, add the following to the top your document:

#+BEGIN_SRC org
,#+TAGS: { @OFFICE(o) @HOME(h) } COMPUTER(c) PHONE(p) READING(r)
#+END_SRC

Reload the document, or press *C-c C-c* on a line starting with #.

Now it is possible to add one or more tags, to any line in your
document. If we press *C-c C-c*, the following will pop up:

#+BEGIN_EXAMPLE
Inherited:
Current:
{ [o] @OFFICE     [h] @HOME    }
  [C] COMPUTER   [p] PHONE   [r] READING
#+END_EXAMPLE

These are the shortcuts we defined at the beginning of our
document. The first two tags (OFFICE and HOME) are mutually exclusive,
the rest can just be added.

A very good example of a GTD setup is: [[http://members.optusnet.com.au/~charles57/GTD/gtd_workflow.html][How I use Emacs and Org mode to
implement GTD]]

** Adding tags to the Emacs config-file

To add tags to the Emacs config-file, so it is available to all your
documents, add the following.

#+BEGIN_SRC emacs-lisp
(setq org-tag-alist '(("@work" . ?w) ("@home" . ?h) ("laptop" . ?l)))
#+END_SRC

To set mutually exclusive groups, like the previous example, see [[https://orgmode.org/org.html#Setting-tags][here]]
in the manual.

It is always possible to override your settings by adding something
else to the top of the document. This way every document can have its
own workflow and/or tags.

An extensive example of working with tags can be found [[http://sachachua.com/blog/2008/01/tagging-in-org-plus-bonus-code-for-timeclocks-and-tags/][here]] as well.

* Export

New shortcuts in this chapter:

- *C-c C-e* -- export menu

Working with Org documents is usually fine, but sometimes you might
want to export your documents to another format.

To export the current document to, for example, html, press *C-c C-e*,
and then *b*. This will export the document and open the new document in
your browser.

Further reading: [[https://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html][HTML publishing tutorial]] (which goes further then
just a document, you can use it to publish a complete website). And
[[https://orgmode.org/manual/Exporting.html#Exporting][the manual]] which explains exporting to HTML, LaTeX, PDF and others.
 
* Becoming proficient with Org mode

To really save time with any efficiency tool, you have to know it
well. To get to know Org mode, reading and using the manual is
important.  Org mode is well documented. The fastest way to read the
ORG mode documentation right in Emacs, in the so-called info-browser.

To call the info browser, use *C-h i*, and use *TAB* to jump from
hyperlink, to hyperlink.

To move around in the info-browser use:

- u -- up
- n -- next
- p -- previous

Besides the Org mode manual, the is the [[https://orgmode.org/worg/][worg website]], which has
many cool ideas and [[https://orgmode.org/worg/org-tutorials/index.html][tutorials]].

For quick reminders there are the [[https://orgmode.org/index.html#sec-4.2][Org mode cheat-sheet]] and the
emacs cheat-sheet, both will help you to remember those pesky
short-cuts.

* Beyond the basics

As is often said in geek humor: "here be dragons!" From here on you
are going into the die-hard section of using Org mode. Most of the
following material is not really hard, but make sure to have backups
of your important data. If you have questions about the following,
look it up in the manual and the faq. Also irc (#orgmode on freenode)
is a good place to ask questions.

** TODO Quickly adding tasks with Capture
** Running the latest version of Org mode

New commands in this section:

- *M-x org-reload* -- reload Org mode after an update
- *M-x org-version* -- show Org mode version

Pretty soon you will notice that the development of Org mode goes a
lot faster the speed Emacs get's updated with. It is quite possible to
run the development version of Org mode daily.

How do you go about that?

1. Install git
   Not really part of an Org mode tutorial, but here are some
   places to start:
   - [[http://code.google.com/p/git-osx-installer/][Git OS X installer]]
   - [[http://code.google.com/p/msysgit/][Myssysgit]] git on Windows
   - On Linux, use your package manager:

   #+BEGIN_SRC sh
   sudo apt-get install git
   #+END_SRC

2. Decide where you will keep the Org mode code, I use
   *~/Build/Emacs/org-mode*, but for Emacs it is really all the
   same, just choose something convenient, and stick with it.

3. Download the latest version of Org mode:

   #+BEGIN_SRC sh
    mkdir ~/Build/Emacs
    cd ~/Build/Emacs
    git clone https://git.savannah.gnu.org/git/emacs/org-mode.git
    cd org-mode && make && make doc
   #+END_SRC

4. Add to your Emacs-init file:

   #+BEGIN_SRC emacs-lisp
   (setq load-path (cons "~/Build/Emacs/org-mode/lisp" load-path))
   (setq load-path (cons "~/Build/Emacs/org-mode/contrib/lisp" load-path))
   #+END_SRC

*Important!* If you run the regular version of Org mode, you have
=(require 'org)= in your config-file.

5. To keep up-to-date with Org mode in the future do:
   
   #+BEGIN_SRC sh
    cd ~/Build/Emacs/org-mode
    git pull && make clean && make && make doc
   #+END_SRC

6. Reload Org mode, using: *M-x org-reload*, or restart Emacs.

To see what version of Org mode you are running: *M-x org-version*
#+END_SRC

* Learn-emacs-lisp in 15 minutes

[[https://learnxinyminutes.com/docs/elisp/]]

[[https://github.com/adambard/learnxinyminutes-docs]]

[[https://github.com/bzg]]

[[https://bzg.fr/]]

[[https://david.rothlis.net/emacs/howtolearn.html]]

#+BEGIN_SRC emacs-lisp

;; This gives an introduction to Emacs Lisp in 15 minutes (v0.2d)
;;
;; First make sure you read this text by Peter Norvig:
;; http://norvig.com/21-days.html
;;
;; Then install GNU Emacs 24.3:
;;
;; Debian: apt-get install emacs (or see your distro instructions)
;; OSX: http://emacsformacosx.com/emacs-builds/Emacs-24.3-universal-10.6.8.dmg
;; Windows: http://ftp.gnu.org/gnu/windows/emacs/emacs-24.3-bin-i386.zip
;;
;; More general information can be found at:
;; http://www.gnu.org/software/emacs/#Obtaining

;; Important warning:
;;
;; Going through this tutorial won't damage your computer unless
;; you get so angry that you throw it on the floor.  In that case,
;; I hereby decline any responsibility.  Have fun!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Fire up Emacs.
;;
;; Hit the `q' key to dismiss the welcome message.
;;
;; Now look at the gray line at the bottom of the window:
;;
;; "*scratch*" is the name of the editing space you are now in.
;; This editing space is called a "buffer".
;;
;; The scratch buffer is the default buffer when opening Emacs.
;; You are never editing files: you are editing buffers that you
;; can save to a file.
;;
;; "Lisp interaction" refers to a set of commands available here.
;;
;; Emacs has a built-in set of commands available in every buffer,
;; and several subsets of commands available when you activate a
;; specific mode.  Here we use the `lisp-interaction-mode', which
;; comes with commands to evaluate and navigate within Elisp code.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Semi-colons start comments anywhere on a line.
;;
;; Elisp programs are made of symbolic expressions ("sexps"):
(+ 2 2)

;; This symbolic expression reads as "Add 2 to 2".

;; Sexps are enclosed into parentheses, possibly nested:
(+ 2 (+ 1 1))

;; A symbolic expression contains atoms or other symbolic
;; expressions.  In the above examples, 1 and 2 are atoms,
;; (+ 2 (+ 1 1)) and (+ 1 1) are symbolic expressions.

;; From `lisp-interaction-mode' you can evaluate sexps.
;; Put the cursor right after the closing parenthesis then
;; hold down the control and hit the j keys ("C-j" for short).

(+ 3 (+ 1 2))
;;           ^ cursor here
;; `C-j' => 6

;; `C-j' inserts the result of the evaluation in the buffer.

;; `C-xC-e' displays the same result in Emacs bottom line,
;; called the "minibuffer".  We will generally use `C-xC-e',
;; as we don't want to clutter the buffer with useless text.

;; `setq' stores a value into a variable:
(setq my-name "Bastien")
;; `C-xC-e' => "Bastien" (displayed in the mini-buffer)

;; `insert' will insert "Hello!" where the cursor is:
(insert "Hello!")
;; `C-xC-e' => "Hello!"

;; We used `insert' with only one argument "Hello!", but
;; we can pass more arguments -- here we use two:

(insert "Hello" " world!")
;; `C-xC-e' => "Hello world!"

;; You can use variables instead of strings:
(insert "Hello, I am " my-name)
;; `C-xC-e' => "Hello, I am Bastien"

;; You can combine sexps into functions:
(defun hello () (insert "Hello, I am " my-name))
;; `C-xC-e' => hello

;; You can evaluate functions:
(hello)
;; `C-xC-e' => Hello, I am Bastien

;; The empty parentheses in the function's definition means that
;; it does not accept arguments.  But always using `my-name' is
;; boring, let's tell the function to accept one argument (here
;; the argument is called "name"):

(defun hello (name) (insert "Hello " name))
;; `C-xC-e' => hello

;; Now let's call the function with the string "you" as the value
;; for its unique argument:
(hello "you")
;; `C-xC-e' => "Hello you"

;; Yeah!

;; Take a breath.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Now switch to a new buffer named "*test*" in another window:

(switch-to-buffer-other-window "*test*")
;; `C-xC-e'
;; => [screen has two windows and cursor is in the *test* buffer]

;; Mouse over the top window and left-click to go back.  Or you can
;; use `C-xo' (i.e. hold down control-x and hit o) to go to the other
;; window interactively.

;; You can combine several sexps with `progn':
(progn
  (switch-to-buffer-other-window "*test*")
  (hello "you"))
;; `C-xC-e'
;; => [The screen has two windows and cursor is in the *test* buffer]

;; Now if you don't mind, I'll stop asking you to hit `C-xC-e': do it
;; for every sexp that follows.

;; Always go back to the *scratch* buffer with the mouse or `C-xo'.

;; It's often useful to erase the buffer:
(progn
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (hello "there"))

;; Or to go back to the other window:
(progn
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (hello "you")
  (other-window 1))

;; You can bind a value to a local variable with `let':
(let ((local-name "you"))
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (hello local-name)
  (other-window 1))

;; No need to use `progn' in that case, since `let' also combines
;; several sexps.

;; Let's format a string:
(format "Hello %s!\n" "visitor")

;; %s is a place-holder for a string, replaced by "visitor".
;; \n is the newline character.

;; Let's refine our function by using format:
(defun hello (name)
  (insert (format "Hello %s!\n" name)))

(hello "you")

;; Let's create another function which uses `let':
(defun greeting (name)
  (let ((your-name "Bastien"))
    (insert (format "Hello %s!\n\nI am %s."
                    name       ; the argument of the function
                    your-name  ; the let-bound variable "Bastien"
                    ))))

;; And evaluate it:
(greeting "you")

;; Some functions are interactive:
(read-from-minibuffer "Enter your name: ")

;; Evaluating this function returns what you entered at the prompt.

;; Let's make our `greeting' function prompt for your name:
(defun greeting (from-name)
  (let ((your-name (read-from-minibuffer "Enter your name: ")))
    (insert (format "Hello!\n\nI am %s and you are %s."
                    from-name ; the argument of the function
                    your-name ; the let-bound var, entered at prompt
                    ))))

(greeting "Bastien")

;; Let's complete it by displaying the results in the other window:
(defun greeting (from-name)
  (let ((your-name (read-from-minibuffer "Enter your name: ")))
    (switch-to-buffer-other-window "*test*")
    (erase-buffer)
    (insert (format "Hello %s!\n\nI am %s." your-name from-name))
    (other-window 1)))

;; Now test it:
(greeting "Bastien")

;; Take a breath.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Let's store a list of names:
;; If you want to create a literal list of data, use ' to stop it from
;; being evaluated - literally, "quote" the data.
(setq list-of-names '("Sarah" "Chloe" "Mathilde"))

;; Get the first element of this list with `car':
(car list-of-names)

;; Get a list of all but the first element with `cdr':
(cdr list-of-names)

;; Add an element to the beginning of a list with `push':
(push "Stephanie" list-of-names)

;; NOTE: `car' and `cdr' don't modify the list, but `push' does.
;; This is an important difference: some functions don't have any
;; side-effects (like `car') while others have (like `push').

;; Let's call `hello' for each element in `list-of-names':
(mapcar 'hello list-of-names)

;; Refine `greeting' to say hello to everyone in `list-of-names':
(defun greeting ()
    (switch-to-buffer-other-window "*test*")
    (erase-buffer)
    (mapcar 'hello list-of-names)
    (other-window 1))

(greeting)

;; Remember the `hello' function we defined above?  It takes one
;; argument, a name.  `mapcar' calls `hello', successively using each
;; element of `list-of-names' as the argument for `hello'.

;; Now let's arrange a bit what we have in the displayed buffer:

(defun replace-hello-by-bonjour ()
    (switch-to-buffer-other-window "*test*")
    (goto-char (point-min))
    (while (search-forward "Hello")
      (replace-match "Bonjour"))
    (other-window 1))

;; (goto-char (point-min)) goes to the beginning of the buffer.
;; (search-forward "Hello") searches for the string "Hello".
;; (while x y) evaluates the y sexp(s) while x returns something.
;; If x returns `nil' (nothing), we exit the while loop.

(replace-hello-by-bonjour)

;; You should see all occurrences of "Hello" in the *test* buffer
;; replaced by "Bonjour".

;; You should also get an error: "Search failed: Hello".
;;
;; To avoid this error, you need to tell `search-forward' whether it
;; should stop searching at some point in the buffer, and whether it
;; should silently fail when nothing is found:

;; (search-forward "Hello" nil t) does the trick:

;; The `nil' argument says: the search is not bound to a position.
;; The `'t' argument says: silently fail when nothing is found.

;; We use this sexp in the function below, which doesn't throw an error:

(defun hello-to-bonjour ()
    (switch-to-buffer-other-window "*test*")
    (erase-buffer)
    ;; Say hello to names in `list-of-names'
    (mapcar 'hello list-of-names)
    (goto-char (point-min))
    ;; Replace "Hello" by "Bonjour"
    (while (search-forward "Hello" nil t)
      (replace-match "Bonjour"))
    (other-window 1))

(hello-to-bonjour)

;; Let's boldify the names:

(defun boldify-names ()
    (switch-to-buffer-other-window "*test*")
    (goto-char (point-min))
    (while (re-search-forward "Bonjour \\(.+\\)!" nil t)
      (add-text-properties (match-beginning 1)
                           (match-end 1)
                           (list 'face 'bold)))
    (other-window 1))

;; This functions introduces `re-search-forward': instead of
;; searching for the string "Bonjour", you search for a pattern,
;; using a "regular expression" (abbreviated in the prefix "re-").

;; The regular expression is "Bonjour \\(.+\\)!" and it reads:
;; the string "Bonjour ", and
;; a group of            | this is the \\( ... \\) construct
;;   any character       | this is the .
;;   possibly repeated   | this is the +
;; and the "!" string.

;; Ready?  Test it!

(boldify-names)

;; `add-text-properties' adds... text properties, like a face.

;; OK, we are done.  Happy hacking!

;; If you want to know more about a variable or a function:
;;
;; C-h v a-variable RET
;; C-h f a-function RET
;;
;; To read the Emacs Lisp manual with Emacs:
;;
;; C-h i m elisp RET
;;
;; To read an online introduction to Emacs Lisp:
;; https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html
#+END_SRC

* Footnotes:
[^1] =*= cannot be used to start a plain list if it is immediatly
     preceded by a newline because it will be interpreted as a heading.

[^2] There are a number of more granular ways to control the exact behavior of headings,
     including use of the special tags =:ARCHIVE:= and =:noexport:=.